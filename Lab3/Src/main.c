/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "main.h"

char RxBuffer[RX_BUFF_SIZE];					//Буфер приёма USART
char TxBuffer[TX_BUFF_SIZE];					//Буфер передачи USART
bool ComReceived;								//Флаг приёма строки данных
uint8_t count = 0;
/**
* @brief  Инициализация систем тактирования:
* 		Источник тактирования: HSI
 * 		Частота: 64МГц
 * @param  None
 * @retval None
 */
void init_clk(void)
{
	// Enable HSI
	RCC->CR |= RCC_CR_HSION;
	while(!(RCC->CR & RCC_CR_HSIRDY)){};

	// Enable Prefetch Buffer
	FLASH->ACR |= FLASH_ACR_PRFTBE;

	// Flash 2 wait state
	FLASH->ACR &= ~FLASH_ACR_LATENCY;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	// HCLK = SYSCLK
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

	// PCLK2 = HCLK
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

	// PCLK1 = HCLK/2
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;

	// PLL configuration: PLLCLK = HSI/2 * 16 = 64 MHz
	RCC->CFGR &= ~RCC_CFGR_PLLSRC;
	RCC->CFGR |= RCC_CFGR_PLLMULL16;

	// Enable PLL
	RCC->CR |= RCC_CR_PLLON;

	// Wait till PLL is ready
	while((RCC->CR & RCC_CR_PLLRDY) == 0) {};

	// Select PLL as system clock source
	RCC->CFGR &= ~RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_PLL;

	// Wait till PLL is used as system clock source
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){};
}

void init_tim(void)
{
	//RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;			//включить тактирование GPIOA
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;			//Включить тактирование TIM6

	//Частота APB1 для таймеров = APB1Clk * 2 = 32МГц * 2 = 64МГц
	TIM2->PSC = 64000-1;						//Предделитель частоты (64МГц/64000 = 1кГц)
	TIM2->ARR = 1000;							//Модуль счёта таймера (1кГц/1000 = 1с)
	TIM2->DIER |= TIM_DIER_UIE;					//Разрешить прерывание по переполнению таймера
	TIM2->CR1 |= TIM_CR1_CEN;					//Включить таймер

	NVIC_EnableIRQ(TIM2_IRQn);					//Рарзрешить прерывание от TIM2
	NVIC_SetPriority(TIM2_IRQn, 2);				//Выставляем приоритет
}
/**
 * @brief  Инициализация портов ввода-вывода
 * @param  None
 * @retval None
 */
void init_ports(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN; // включить тактирование GPIOC
	// очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF0 | GPIO_CRL_MODE0);
	// и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE0_1; // PC0, выход 2МГц
	// очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF1 | GPIO_CRL_MODE1);
	// и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE1_1; // PC1, выход 2МГц
	// очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF2 | GPIO_CRL_MODE2);
	// и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE2_1; // PC2, выход 2МГц
	// очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF3 | GPIO_CRL_MODE3);
	// и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE3_1; // PC3, выход 2МГц
	// очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4);
	// и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE4_1; // PC4, выход 2МГц
	// очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF5 | GPIO_CRL_MODE5);
	// и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE5_1; // PC5, выход 2МГц
	// очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF6 | GPIO_CRL_MODE6);
	// и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE6_1; // PC6, выход 2МГц
}

/**
 * @brief  Инициализация прерывания от кнопки (PC12,13)
 * @param  None
 * @retval None
 */
void init_button(void)
{
	// PC13 и PC12
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;

	// GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);
	// 	//...и выставляем так, как нам нужно
	// GPIOC->CRH |= GPIO_CRH_CNF13_1;			//Вход с подтяжкой
	// GPIOC->BSRR |= GPIO_BSRR_BS13;			//Подтяжка к Vdd

	GPIOC->CRH &= ~(GPIO_CRH_MODE12 | GPIO_CRH_CNF12);//...и выставляем так, как нам нужно
	GPIOC->CRH |= GPIO_CRH_CNF12_0; // input floating

	/* Настройка самого прерывания */

	// Настройка альтернативных фукнций портов.
	// Настройки портов с 12 по 15 хранятся в регистре AFIO_EXTICR4.
	// Регистры объединены в массив AFIO->EXTICR, нумерация массива начинается с нулевого элемента.
	// Поэтому настройки AFIO_EXTICR4 хранятся в AFIO->EXTICR[3]
	AFIO->EXTICR[3] |= AFIO_EXTICR4_EXTI13_PC;

	EXTI->IMR |= EXTI_IMR_MR13;	  // Выставляем маску - EXTI13
	EXTI->FTSR |= EXTI_FTSR_TR13; // Прерывание по спаду импульса (при нажатии на кнопку)

	AFIO->EXTICR[3] |= AFIO_EXTICR4_EXTI12_PC;

	EXTI->IMR |= EXTI_IMR_MR12;	  // Выставляем маску - EXTI12
	EXTI->FTSR |= EXTI_FTSR_TR12; // Прерывание по спаду импульса (при нажатии на кнопку)

	NVIC_EnableIRQ(EXTI15_10_IRQn);
	NVIC_SetPriority(EXTI15_10_IRQn, 1);
}

/**
 * @brief  Подпрограмма обработчика прерывания
 *			по внешнему импульсу на выводах (EXTI15-EXTI10)
 *			Нас интересует EXTI13, там висит кнопка.
 * @param  None
 * @retval None
 */
void EXTI15_10_IRQHandler(void)
{
	// Т.к. этот обработчик вызывается, если произошло одно из прерываний EXTI15-EXI10, нужно проверить, кто из них его вызвал.
	if (EXTI->PR & EXTI_PR_PR12) // нас интересует EXTI12
	{
		delay(10000);			  // Задержка для защиты от дребезга контактов
		EXTI->PR |= EXTI_PR_PR12; // сброс флага
		TIM2->CR1 ^= TIM_CR1_CEN; // Инвертируем состояние таймера
	}

	// Т.к. этот обработчик вызывается, если произошло одно из прерываний EXTI15-EXI10,нужно проверить, кто из них его вызвал.
	else if (EXTI->PR & EXTI_PR_PR13) // нас интересует EXTI13
	{
		delay(10000);			  // Задержка для защиты от дребезга контактов
		EXTI->PR |= EXTI_PR_PR13; // сброс флага
		increment();			  // fun for counts of button
		indicator();
	}
}

void TIM2_IRQHandler(void)
{
	TIM2->SR &= ~TIM_SR_UIF;
	increment();
	indicator();
}

void reset_all(void)
{
	GPIOC->BSRR |= GPIO_BSRR_BR0 | GPIO_BSRR_BR1 | GPIO_BSRR_BR2 | GPIO_BSRR_BR3 | GPIO_BSRR_BR4 | GPIO_BSRR_BR5 | GPIO_BSRR_BR6;
	//	GPIO_BSRR_BR0			@ сбрасываем в '0'
	//	GPIO_BSRR_BS0			@ в '1'
	return;
}

void increment(void)
{
	if (count > 8)
		count = 0;
	else
		count++;
}

void indicator(void)
{
	reset_all();
	switch (count)
	{
	case 0:
		GPIOC->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS5;
		break;
	case 1:
		GPIOC->BSRR |= GPIO_BSRR_BS1 | GPIO_BSRR_BS2;
		break;
	case 2:
		GPIOC->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS6;
		break;
	case 3:
		GPIOC->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS6;
		break;
	case 4:
		GPIOC->BSRR |= GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS5 | GPIO_BSRR_BS6;
		break;
	case 5:
		GPIOC->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS5 | GPIO_BSRR_BS6;
		break;
	case 6:
		GPIOC->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS5 | GPIO_BSRR_BS6;
		break;
	case 7:
		GPIOC->BSRR |= GPIO_BSRR_BS1 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2;
		break;
	case 8:
		GPIOC->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS5 | GPIO_BSRR_BS6;
	case 9:
		GPIOC->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS5 | GPIO_BSRR_BS6;
		break;
	default:
		break;
	}
}

void init_usart2(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;						//
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;						//включить тактирование альтернативных ф-ций портов
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;					//включить тактирование UART2

	GPIOA->CRL &= ~(GPIO_CRL_MODE2 | GPIO_CRL_CNF2);		//PA2 на выход
	GPIOA->CRL |= (GPIO_CRL_MODE2_1 | GPIO_CRL_CNF2_1);

	GPIOA->CRL &= ~(GPIO_CRL_MODE3 | GPIO_CRL_CNF3);		//PA3 - вход
	GPIOA->CRL |= GPIO_CRL_CNF3_0;

	/*****************************************
	Скорость передачи данных - 115200
	Частота шины APB1 - 32МГц

	1. USARTDIV = 32'000'000/(16*115200) = 17.4
	2. 17 = 0x11
	3. 16*0.4 = 6
	4. Итого 0x116
	*****************************************/
	USART2->BRR = 0xFA;

	USART2->CR1 |= USART_CR1_RE | USART_CR1_TE | USART_CR1_UE;
	USART2->CR1 |= USART_CR1_RXNEIE;						//разрешить прерывание по приему байта данных

	NVIC_EnableIRQ(USART2_IRQn);
	NVIC_SetPriority(USART2_IRQn, 2);
}

void USART2_IRQHandler(void)
{
	if ((USART2->SR & USART_SR_RXNE)!=0)		//Прерывание по приёму данных // проверка на наличие данных
	{
		uint8_t pos = strlen(RxBuffer);			//Вычисляем позицию свободной ячейки
		RxBuffer[pos] = USART2->DR;				//Считываем содержимое регистра данных
		if ((RxBuffer[pos - 1] == 0x0D) && (RxBuffer[pos] == 0x0A))//0x0D=\r , 0x0A=\n
		{
			ComReceived = true; //- выставляем флаг приёма строки
			return;				//- и выходим
		}
	}
}

/**
  * @brief  Передача строки по USART2 без DMA
  * @param  *str - указатель на строку
  * @param  crlf - если true, перед отправкой добавить строке символы конца строки
  * @retval None
  */
void SendString(char *str)
{
	uint16_t i;
	strcat(str, "\r\n");	//добавляем символ конца строки
	for (i = 0; i < strlen(str); i++)
	{
		USART2->DR = str[i];								//передаём байт данных
		while ((USART2->SR & USART_SR_TC)==0) {};			//ждём окончания передачи
	}
}


/**
  * @brief  Обработчик команд
  * @param  None
  * @retval None
  */
void ExecuteCommand(void)
{
	memset(TxBuffer,0,sizeof(TxBuffer));					//Очистка буфера передачи
	/* Обработчик команд */
	if (strncmp(RxBuffer,"*IDN?",strlen("*IDN?")) == 0)					//Это команда "*IDN?"
	{
		//Она самая, возвращаем строку идентификации
		strcpy(TxBuffer,"YakimovAOIU72");
	}
	else if (strncmp(RxBuffer,"INC",strlen("INC")) == 0)				//Команда запуска таймера?
	{
		count++;
		strcpy(TxBuffer, "OK");
	}
	else if (strncmp(RxBuffer,"VALUE?",strlen("VALUE?")) == 0)				//Команда остановки таймера?
	{
		sprintf(TxBuffer,"%d", count);
	}
//	else if (strncmp(RxBuffer,"STOP",strlen("STOP")) == 0)				//Команда остановки таймера?
//	{
//		TIM2->CR1 ^= TIM_CR1_CEN; // Инвертируем состояние таймера
//		strcpy(TxBuffer, "OK");
//	}
	else if (strncmp(RxBuffer,"PERIOD ",strlen("PERIOD ")) == 0)				//Команда изменения периода таймера?
	{
		uint16_t tim_value;
		sscanf(RxBuffer,"%*s %hu", &tim_value);				//преобразуем строку в целое число
		if ((100 <= tim_value) && (tim_value <= 3000))		//параметр должен быть в заданных пределах!
			{
				TIM2->ARR = tim_value-1;
				TIM2->CNT = 0;
				strcpy(TxBuffer, "OK");
			}
		else
				strcpy(TxBuffer, "INVALID PARAM");	//ругаемся
	}
	else strcpy(TxBuffer,"UNKOWN COMMAND");					//Если мы не знаем, чего от нас хотят, ругаемся в ответ
	SendString(TxBuffer);
	memset(RxBuffer, 0, sizeof(RxBuffer)); // Очистка буфера приёма									//Сбрасываем флаг приёма строки
	ComReceived = false;
}

int main(void)
{
	/*Инициализации всякие*/
		init_clk();
		init_ports();
		init_button();
		init_tim();
		init_usart2();
		indicator();
		while(true)
		{
			if (ComReceived)				//Ждём приема строки
				ExecuteCommand();
		};
}

void delay(uint32_t takts)
{
	for (uint32_t i = 0; i < takts; i++) {};
}
