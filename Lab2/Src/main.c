/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "main.h"
//PC - APB2
//PC0-6
//PC 12,13 for button

uint8_t count = 0;
/**
  * @brief  Инициализация портов ввода-вывода
  * @param  None
  * @retval None
  */
void init_ports(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;	//включить тактирование GPIOC
	//очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF0 | GPIO_CRL_MODE0);
	//и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE0_1;		//PC0, выход 2МГц
	//очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF1 | GPIO_CRL_MODE1);
	//и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE1_1;		//PC1, выход 2МГц
	//очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF2 | GPIO_CRL_MODE2);
	//и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE2_1;		//PC2, выход 2МГц
	//очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF3 | GPIO_CRL_MODE3);
	//и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE3_1;		//PC3, выход 2МГц
	//очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4);
	//и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE4_1;		//PC4, выход 2МГц
	//очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF5 | GPIO_CRL_MODE5);
	//и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE5_1;		//PC5, выход 2МГц
	//очистка полей
	GPIOC->CRL &= ~(GPIO_CRL_CNF6 | GPIO_CRL_MODE6);
	//и конфигурация
	GPIOC->CRL |= GPIO_CRL_MODE6_1;		//PC6, выход 2МГц
}

/**
  * @brief  Инициализация прерывания от кнопки (PC12,13)
  * @param  None
  * @retval None
  */
void init_button(void) {
	//PC13 и PC12
	RCC->APB2ENR |=  RCC_APB2ENR_AFIOEN;

	// GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);
	// 	//...и выставляем так, как нам нужно
	// GPIOC->CRH |= GPIO_CRH_CNF13_1;			//Вход с подтяжкой
	// GPIOC->BSRR |= GPIO_BSRR_BS13;			//Подтяжка к Vdd

	GPIOC->CRH &= ~(GPIO_CRH_MODE12 | GPIO_CRH_CNF12);//...и выставляем так, как нам нужно
	GPIOC->CRH |= GPIO_CRH_CNF12_0;			//input floating

	/* Настройка самого прерывания */

	// Настройка альтернативных фукнций портов.
	// Настройки портов с 12 по 15 хранятся в регистре AFIO_EXTICR4.
	// Регистры объединены в массив AFIO->EXTICR, нумерация массива начинается с нулевого элемента.
	// Поэтому настройки AFIO_EXTICR4 хранятся в AFIO->EXTICR[3]
	AFIO->EXTICR[3] |= AFIO_EXTICR4_EXTI13_PC;

	EXTI->IMR |= EXTI_IMR_MR13;	  // Выставляем маску - EXTI13
	EXTI->FTSR |= EXTI_FTSR_TR13; // Прерывание по спаду импульса (при нажатии на кнопку)

	AFIO->EXTICR[3] |= AFIO_EXTICR4_EXTI12_PC;

	EXTI->IMR |= EXTI_IMR_MR12;	//Выставляем маску - EXTI12
	EXTI->FTSR |= EXTI_FTSR_TR12;	//Прерывание по спаду импульса (при нажатии на кнопку)

	NVIC_EnableIRQ(EXTI15_10_IRQn);
	NVIC_SetPriority(EXTI15_10_IRQn,1);
}

/**
  * @brief  Подпрограмма обработчика прерывания
  *			по внешнему импульсу на выводах (EXTI15-EXTI10)
  *			Нас интересует EXTI13, там висит кнопка.
  * @param  None
  * @retval None
  */
void EXTI15_10_IRQHandler(void)
{
	// Т.к. этот обработчик вызывается, если произошло одно из прерываний EXTI15-EXI10, нужно проверить, кто из них его вызвал.
	if (EXTI->PR & EXTI_PR_PR12) 		// нас интересует EXTI12
	{
		delay(10000);					//Задержка для защиты от дребезга контактов
		EXTI->PR |= EXTI_PR_PR12;		// сброс флага
		TIM2->CR1 ^= TIM_CR1_CEN;		//Инвертируем состояние таймера
	}

	// Т.к. этот обработчик вызывается, если произошло одно из прерываний EXTI15-EXI10,нужно проверить, кто из них его вызвал.
	else if (EXTI->PR & EXTI_PR_PR13) 		// нас интересует EXTI13
	{
		delay(10000);					//Задержка для защиты от дребезга контактов
		EXTI->PR |= EXTI_PR_PR13;		//сброс флага
		increment();					//fun for counts of button
		indicator();
	}
}

void reset_all(void){
	GPIOC->BSRR |= GPIO_BSRR_BR0 |  GPIO_BSRR_BR1 | GPIO_BSRR_BR2 | GPIO_BSRR_BR3 | GPIO_BSRR_BR4 | GPIO_BSRR_BR5 | GPIO_BSRR_BR6;
	//	GPIO_BSRR_BR0			@ сбрасываем в '0'
	//	GPIO_BSRR_BS0			@ в '1'
	return;
}

void increment(void){
	if (count > 8)	count = 0;
	else count++;
}

void indicator(void){
	reset_all();
	switch(count)
	  {
	  case 0:
	    GPIOC->ODR |= GPIO_ODR_ODR0 |  GPIO_ODR_ODR1 | GPIO_ODR_ODR2 | GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR5;
	    break;
	  case 1:
	    GPIOC->ODR |= GPIO_ODR_ODR1 | GPIO_ODR_ODR2;
	    break;
	  case 2:
	    GPIOC->ODR |= GPIO_ODR_ODR0 |  GPIO_ODR_ODR1 | GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR6;
	    break;
	  case 3:
	    GPIOC->ODR |= GPIO_ODR_ODR0 |  GPIO_ODR_ODR1 | GPIO_ODR_ODR2 | GPIO_ODR_ODR3 | GPIO_ODR_ODR6;
	    break;
	  case 4:
	    GPIOC->ODR |= GPIO_ODR_ODR1 | GPIO_ODR_ODR2 | GPIO_ODR_ODR5 | GPIO_ODR_ODR6;
	    break;
	  case 5:
	    GPIOC->ODR |= GPIO_ODR_ODR0 | GPIO_ODR_ODR2 | GPIO_ODR_ODR3 | GPIO_ODR_ODR5 | GPIO_ODR_ODR6;
	    break;
	  case 6:
	    GPIOC->ODR |= GPIO_ODR_ODR0 | GPIO_ODR_ODR2 | GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR5 | GPIO_ODR_ODR6;
	    break;
	  case 7:
	    GPIOC->ODR |= GPIO_ODR_ODR1| GPIO_ODR_ODR1 | GPIO_ODR_ODR2;
	    break;
	  case 8:
	    GPIOC->ODR |= GPIO_ODR_ODR0 |  GPIO_ODR_ODR1 | GPIO_ODR_ODR2 | GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR5 | GPIO_ODR_ODR6;
	  case 9:
	  	GPIOC->ODR |= GPIO_ODR_ODR0 |  GPIO_ODR_ODR1 | GPIO_ODR_ODR2 | GPIO_ODR_ODR3 | GPIO_ODR_ODR5 | GPIO_ODR_ODR6;
	    break;
	  default:
	    break;
	  }
}
void init_tim(void) {

	//RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	//Частота APB1 для таймеров = APB1Clk * 2 = 32МГц * 2 = 64МГц
	TIM2->PSC = 64000-1;						//Предделитель частоты (64МГц/32000 = 10кГц)
	TIM2->ARR = 1000-1;						//Модуль счёта таймера (10кГц/1000 = 1с)
	TIM2->DIER |= TIM_DIER_UIE;				//Разрешить прерывание по переполнению таймера
	TIM2->CR1 |= TIM_CR1_CEN;				//Включить таймер

	NVIC_EnableIRQ(TIM2_IRQn);				//Разрешить прерывание от TIM2
	NVIC_SetPriority(TIM2_IRQn, 2);			//Выставляем приоритет
}

void TIM2_IRQHandler(void) {
	TIM2->SR &= ~TIM_SR_UIF;
	increment();
	indicator();
}

void init_clk(void)
{
	// Enable HSI
	RCC->CR |= RCC_CR_HSION;
	while(!(RCC->CR & RCC_CR_HSIRDY)){};

	// Enable Prefetch Buffer
	FLASH->ACR |= FLASH_ACR_PRFTBE;

	// Flash 2 wait state
	FLASH->ACR &= ~FLASH_ACR_LATENCY;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	// HCLK = SYSCLK
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

	// PCLK2 = HCLK
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

	// PCLK1 = HCLK/2
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;

	// PLL configuration: PLLCLK = HSI/2 * 16 = 64 MHz
	RCC->CFGR &= ~RCC_CFGR_PLLSRC;
	RCC->CFGR |= RCC_CFGR_PLLMULL16;

	// Enable PLL
	RCC->CR |= RCC_CR_PLLON;

	// Wait till PLL is ready
	while((RCC->CR & RCC_CR_PLLRDY) == 0) {};

	// Select PLL as system clock source
	RCC->CFGR &= ~RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_PLL;

	// Wait till PLL is used as system clock source
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){};
}

int main(void)
{
	init_clk();
	init_ports();
	init_button();
	init_tim();
	indicator(); // выставим '0'
	while (true){};
}

void delay(uint32_t value) {
	for (uint32_t i=0; i<value; i++);
}
