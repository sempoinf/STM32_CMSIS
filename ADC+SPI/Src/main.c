/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

int16_t tx_index = 0; // тут хранится количество переданных байт
int16_t tx_len = 0;   // сколько всего байт нужно передать
uint8_t *tx_data;     // указатель на массив с передаваемыми данными
int8_t data[2];     // проверить буфер для передачи

int main(void)
{
	init_clk(); // инициализация системы тактирования
	SPI1_Init(); // инициализация SPI1
	init_adc1(); // инициализация АЦП
	initTIM2();	 // инициализация TIM2
	while (true){};
}
/**
 * @brief  Инициализация систем тактирования:
 * 		Источник тактирования: HSI
 * 		Частота: 64МГц
 * @param  None
 * @retval None
 */
void init_clk(void)				// settings of frequency 64M Hz
{
		// Enable HSI
		RCC->CR |= RCC_CR_HSION;
		while(!(RCC->CR & RCC_CR_HSIRDY)){};
		// Enable Prefetch Buffer
		FLASH->ACR |= FLASH_ACR_PRFTBE;
		// Flash 2 wait state
		FLASH->ACR &= ~FLASH_ACR_LATENCY;
		FLASH->ACR |= FLASH_ACR_LATENCY_2;
		// HCLK = SYSCLK
		RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
		// PCLK2 = HCLK
		RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
		// PCLK1 = HCLK
		RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
		// PLL configuration: PLLCLK = HSI/2 * 16 = 64 MHz
		RCC->CFGR &= ~RCC_CFGR_PLLSRC;
		RCC->CFGR |= RCC_CFGR_PLLMULL16;
		// Enable PLL
		RCC->CR |= RCC_CR_PLLON;
		// Wait till PLL is ready
		while((RCC->CR & RCC_CR_PLLRDY) == 0) {};
		// Select PLL as system clock source
		RCC->CFGR &= ~RCC_CFGR_SW;
		RCC->CFGR |= RCC_CFGR_SW_PLL;
		// Wait till PLL is used as system clock source
		while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){};
}
void SPI1_IRQHandler(void)
{
	GPIOA->BSRR = GPIO_BSRR_BR4;  // Устанавливаем бит 4 (SS) в 0
    while(tx_index < tx_len) //проверка на длину массива
    {
    	while(!(SPI1->SR & SPI_SR_TXE)); //Transmit Buffer Empty пока не станет 1, то есть буффер пустой, значит можно передавать
        // Передача данных
        SPI1->DR = data[tx_index++]; //Запись значения в регистр данных SPI->передача данных
    }
    // Все данные переданы, деактивируем slave и отключаем прерывание
    GPIOA->BSRR = GPIO_BSRR_BS4;  // Устанавливаем бит 4 (SS) в единицу
    SPI1->CR2 &= ~(SPI_CR2_TXEIE);  // Отключаем прерывание по передаче данных (TXE)
}
void SPI1_Init(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN | RCC_APB2ENR_IOPAEN; // Включаем тактирование SPI1 и GPIOA

	/**********************************************************/
	/*** Настройка выводов GPIOA на работу совместно с SPI1 ***/
	/**********************************************************/

	// PA7 - MOSI PA6 - MISO PA5 - SCK PA4 - NSS This is an optional pin to select a slave device.
	// Для начала сбрасываем все конфигурационные биты в нули
	GPIOA->CRL &= ~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4 | GPIO_CRL_CNF5 | GPIO_CRL_MODE5 | GPIO_CRL_CNF6 | GPIO_CRL_MODE6 | GPIO_CRL_CNF7 | GPIO_CRL_MODE7);
	GPIOA->CRL |= (GPIO_CRL_MODE4_0); 					// PA4 выход 10MHz
	GPIOA->CRL |= (GPIO_CRL_CNF5_1 | GPIO_CRL_MODE5_0); // PA5 выход 10MHz altern push-pull
	GPIOA->CRL |= (GPIO_CRL_CNF6_0);					// PA6 Floating input
	GPIOA->CRL |= (GPIO_CRL_CNF7_1 | GPIO_CRL_MODE7_0); // PA7 выход 10MHz altern push-pull

	// SCK: MODE5 = 0x03 (11b); CNF5 = 0x02 (10b)   // Alternate function output Push-pull 50MHz
	//GPIOA->CRL |= (0x02 << GPIO_CRL_CNF5_Pos) | (0x03 << GPIO_CRL_MODE5_Pos);

	// MISO: MODE6 = 0x00 (00b); CNF6 = 0x01 (01b) //Floating input
	// GPIOA->CRL |= (0x01 << GPIO_CRL_CNF6_Pos) | (0x00 << GPIO_CRL_MODE6_Pos);

	// MOSI: MODE7 = 0x03 (11b); CNF7 = 0x02 (10b)  // Alternate function output Push-pull 50MHz
	//GPIOA->CRL |= (0x02 << GPIO_CRL_CNF7_Pos) | (0x03 << GPIO_CRL_MODE7_Pos);

	/*
	//SS MODE4 = 0x03 (11b); CNF4 = 0x02 (10b)  // Alternate function output Push-pull 50MHz
	GPIOA->CRL |= (0x02<<GPIO_CRL_CNF4_Pos) | (0x03<<GPIO_CRL_MODE4_Pos);
	*/

	/**********************/
	/*** Настройка SPI1 ***/
	/**********************/
	SPI1->CR1 |= 0 << SPI_CR1_DFF_Pos							  // Размер кадра 8 бит, 1 -> 16 бит
				 | 0 << SPI_CR1_LSBFIRST_Pos					  // MSB first 0 - старший бит передается первым, 1 - наоборот
				 | SPI_CR1_SSM									  // Программное управление SS
				 | SPI_CR1_SSI									  // SS в высоком состоянии (для работы в режиме MASTER)
				 | SPI_CR1_BR_0									  // Скорость передачи: F_PCLK/8 -> 8МHz
				 | SPI_CR1_MSTR									  // Режим Master (ведущий)
				 | 0 << SPI_CR1_CPOL_Pos | 0 << SPI_CR1_CPHA_Pos; // Режим работы SPI: 0 (тактовый сигнал лог. "0" - 0, считывание по возрастанию)

	SPI1->CR1 |= SPI_CR1_SPE; // разрешить SPI1

	NVIC_EnableIRQ(SPI1_IRQn);		// Разрешаем прерывания от SPI1
	NVIC_SetPriority(SPI1_IRQn, 3); // Выставляем приоритет
}


void init_adc1(void)
{ // Инициализация АЦП ADC1 на работу с регулярной группой каналов, PC4,5 подключен к выходу аналоговой части

	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;				 // Включить тактирование порта GPIOC
	GPIOC->CRL &= ~(GPIO_CRL_MODE4 | GPIO_CRL_CNF4); // PC4 на вход
	GPIOC->CRL &= ~(GPIO_CRL_MODE5 | GPIO_CRL_CNF5); // PC5 на вход
//  GPIOC->CRL &= ~(GPIO_CRL_CNF4_Msk | GPIO_CRL_MODE4_Msk);
//  GPIOC->CRL |= (0x00 << GPIO_CRL_CNF4_Pos) | (0x00 << GPIO_CRL_MODE4_Pos);

	RCC->CFGR &= ~RCC_CFGR_ADCPRE;
	RCC->CFGR |= RCC_CFGR_ADCPRE_DIV8;				 // прескейлер = 8 -> clock adc1 = 8 MHz ADC clock frequency ->14 max
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;				 // Включить тактирование АЦП

	ADC1->CR2 &= ~ADC_CR2_CONT;						 // Вкл режима одиночного преобразования по запросу

	// // Установка канала 14 в первую позицию в последовательности
	// ADC1->SQR3 &= ~ADC_SQR3_SQ1;
	// ADC1->SQR3 |= (14 << ADC_SQR3_SQ1_Pos);

	// Настройка времени преобразования каналов 240 очень долго, зато точно! SMPR1 - 10-17 канала, SMPR2 - 0-9
	ADC1->SMPR1 |= ADC_SMPR1_SMP14; // Канал 14 - 239.5 тактов 111 в SMP14[2:0]
	ADC1->SMPR1 |= ADC_SMPR1_SMP15; // Канал 15 - 239.5 тактов 111 в SMP15[2:0]

	ADC1->CR2 |= ADC_CR2_EXTSEL;	// Выбрать в качестве источника запуска SWSTART
	ADC1->CR2 |= ADC_CR2_EXTTRIG;	// Разрешить внешний запуск регулярного канала
	ADC1->CR2 |= ADC_CR2_ADON;		// Включить АЦП + start conversion

	Delay(5);				  // Задержка перед калибровкой
	//Before starting a calibration, the ADC must have been in power-on state (ADON bit = ‘1’) for at least two ADC clock cycles.
	ADC1->CR2 |= ADC_CR2_CAL; // Запуск калибровки, избежать неточностей	Calibration time 1/Fadc
	while (!(ADC1->CR2 & ADC_CR2_CAL)){}; // Ожидание окончания калибровки
}
/**
 * @brief  Подпрограмма задержки
 * @param  counter - Кол-во тактов
 * @retval None
 */
void Delay(uint32_t counter)
{	
	for (uint32_t i = 0; i < counter; i++){};
}

void SPI1_Tx(uint8_t *data, int16_t len)
	{
	if (len <= 0)
	return;
	// Ждем, пока SPI освободится от предыдущей передачи
	while (SPI1->SR & SPI_SR_BSY);
	// Настройка переменных, которые будут
	// использоваться в обработчике прерывания SPI
	tx_index = 0;
	tx_len = len;
	tx_data = data;
	// Разрешаем прерывание TXEIE И запускаем обмен
	SPI1->CR2 |= SPI_CR2_TXEIE; //когда TX буффер пуст - TXE flag
}
void Adc_Measure(void)
{
	int16_t adc_volts_14 = Read_ADC(14); // считываем значение с АЦП с 14 каналов
	int16_t adc_volts_15 = Read_ADC(15); // считываем значение с АЦП с 15 каналов
	// formula for calculating the volts from value of adc1
	float f = ((adc_volts_14 - adc_volts_15) * V_REF * 1000) / ADC_FS; // считаем разницу и в мВ
	int16_t volts = (int16_t)f; //неявное преобрахование float -> int16
	memset(data, 0, sizeof(data)); // Очистка буфера передачи
	// представление 16-разряд знак число - двух байтов little-endian (менее значимый байт идет первым)
	data[0] = (uint8_t)(volts & 0xFF);//содержит мл байт
	data[1] = (uint8_t)((volts >> 8) & 0xFF); //старший байт
	// представление 16-разряд знак число - двух байтов big--endian (больше значимый байт идет первым
	// data[0] = (uint8_t)((volts >> 8) & 0xFF);
	// data[1] = (uint8_t)(volts & 0xFF);
}
int16_t Read_ADC(uint8_t n) // в данном случае всегда 14й и 15 канал, так как используем только PC4 и PC5
{
	ADC1->DR = 0; //очистка регистра 16 разрядов
	ADC1->SQR3 = n;				  // Записываем номер канала в регистр SQR3 для последовательности преобразования max 16 в последовательности 
	ADC1->CR2 |= ADC_CR2_SWSTART; // Запускаем преобразование в регулярном канале (запуск АЦП) STRT: Regular channel Start flag
	while (!(ADC1->SR & ADC_SR_EOC));// Ждем окончания преобразования (End of Conversion - EOC, если 1 -> закончил)
	return ADC1->DR; // возвращаем результат измерения
}

void initTIM2(void)
{
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;    //Включить тактирование TIM2
	//Частота APB1 для таймеров = APB1Clk * 2 = 32МГц * 2 = 64МГц
	TIM2->PSC = 64000-1;          //Предделитель частоты (64МГц/64000 = 1кГц)
	TIM2->ARR = 1000;            //Модуль счёта таймера (1кГц/1000 = 1с)
	TIM2->DIER |= TIM_DIER_UIE;//Разрешить прерывание по переполнению таймера
	TIM2->CR1 |= TIM_CR1_CEN;        //Включить таймер
	NVIC_EnableIRQ(TIM2_IRQn);        //Рарзрешить прерывание от TIM2
	NVIC_SetPriority(TIM2_IRQn, 2);      //Выставляем приоритет
}

void TIM2_IRQHandler(void)
{
	TIM2->SR &= ~TIM_SR_UIF;      //Сброс флага переполнения
	Adc_Measure();//отработка модуля АЦП
	SPI1_Tx(data, sizeof(data)); // передача через SPI
}